#to install the anytree module run: $ pip install anytree
from anytree import Node, RenderTree

#function to add new node
def addT( name,par = None ):
		#case node doesn't have a parent
		if par == None: aux = Node( name,parent = None )
		#other case; "has a parent"
		else: aux = Node( name,parent = par )
		#return Node aux
		return aux

#function to print Tree with givin root
def printT( root ):
	for pre,fill,node in RenderTree( root ):
		print( "%s%s" % ( pre,node.name ) )

#function to create AST
def parse_program( lexer ):
	#case the list isn't empyt and function parse_function returns a value
	if len( lexer ) > 0 and parse_function( lexer ):
		#saves node generated by parse_function ("Main")
		p = parse_function( lexer )
		#creates node "Program"
		Prog = addT( "program" )
		#sets node generated by parse_function ( node "Function") as a child for node "Program"
		p.parent = Prog
		#returns node
		return Prog
	#print error for other case	
	else:
		print ( "Syntax error" )
		exit()

#function to parse function
def parse_function( fun ):
	#checks syntaxis
	if fun[0][0] != "INT K": return False
	if fun[1][0] != "IDENTIFIER": return False
	if fun[2][0] != "OPEN PA": return False
	if fun[3][0] != "CLOSE PA": return False
	if fun[4][0] != "OPEN BR": return False
	#calls parse_statement to see if it can create a node
	if parse_statement( fun[5:] ):
		#saves in variable; "a" has node "Return", "b" has remaining list
		a,b = parse_statement( fun[5:] )
		#checks syntaxis
		if b[0][0] != "CLOSE BR": return False
		#creates a node "Main" for function
		Main = addT( fun[1][1] )
		#sets node "Main" as a parent for "Return" node
		a.parent = Main
		#returns node "Main"
		return Main

#function to parse statements
def parse_statement( st ):
	#checks syntaxis
	if st[0][0] != "RETURN K": return False
	#calls function to parse expression
	if parse_exp( st[1:] ):
		#saves it in variables, "a" has node "Cte", "b" has remaining list
		a,b = parse_exp( st[1:] )
		#checks syntaxis
		if b[0][0] != "SEMIC": return False
		#creates a node "Re" for return
		Re = addT( "return" )
		#sets node "Re" as a parent for "Cte" node
		a.parent = Re
		#returns node "Re" and remaining list of tokens to check syntaxis
		return Re,b[1:]
			
#function to parse expressions
def parse_exp( ex ):
	#checks syntaxis
	if ex[0][0] != "INT": return False
	#creates node "Cte" with number
	Cte = addT( ex[0][1] )
	#returns node "Cte" and remaining list of tokens to check syntaxis
	return Cte, ex[1:]