open Lexer;;

type ast =
Node of token list * ast * ast
|Leaf
(*Para definir un nodo, hacemos Node (token, Leaf|Node, Leaf|Node) *)


(*definiciÃ³n*)
type exp = Const(int)
type statement = Return(exp)
type fun_decl = Fun(string, statement)
type prog = Prog(fun_decl)


(*lista con elementos de distintos tipos, no es posible*)
type exp = Int
type statement = ReturnKeyword::exp::Semicolon
type fun_decl = IntKeyword::MainKeyword::OpenParen::CloseParen::OpenBrace::statement::CloseBrace::[]
type prog = fun_decl

(* val parser : Tokens.token list -> AST = <fun>
Recibe una lista de tokens y regresa un AST*)
let parser = parse tokens


(*Para el caso particular de return_2.c, parse recibe:
IntKeyword, MainKeyword, OpenParen, CloseParen, OpenBrace, ReturnKeyword, Int 2, Semicolon, CloseBrace
*)